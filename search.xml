<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>To Be a FullStackDeveloper</title>
    <url>/2020/06/14/To-Be-a-FullStackDeveloper/</url>
    <content><![CDATA[<p>这里是我的个人博客</p>
<blockquote>
<p>欢迎加我QQ：1138694667</p>
<p>邮箱：<a href="mailto:1138694667@qq.com">1138694667@qq.com</a></p>
<p>欢迎 访问GitHub</p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>简介</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-03</title>
    <url>/2020/06/14/JavaSE-03/</url>
    <content><![CDATA[<h1 id="JUnit单元测试"><a href="#JUnit单元测试" class="headerlink" title="JUnit单元测试"></a>JUnit单元测试</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>单元测试时针对最小功能单元编写测试代码。</li>
<li>JAVA程序最小功能单元时方法</li>
<li>单元测试就是针对单个JAVA方法的测试</li>
</ul>
<h2 id="Test-Driven-Development-TDD-测试驱动开发"><a href="#Test-Driven-Development-TDD-测试驱动开发" class="headerlink" title="Test-Driven Development(TDD 测试驱动开发)"></a>Test-Driven Development(TDD 测试驱动开发)</h2><h2 id="JUnit设计"><a href="#JUnit设计" class="headerlink" title="JUnit设计"></a>JUnit设计</h2><ul>
<li>TestCase： 代表一个测试</li>
<li>TestSuit：一个TestSuit包含一组TestCase，表示一组测试</li>
<li>TestFixture：一个TestFixture表示一个测试环境</li>
<li>TestResult：用于收集测试结果</li>
<li>TestRunner：用于运行测试</li>
<li>TestListener：用于监听测试过程，收集测试数据</li>
<li>Assert：用于断言测试结果是否正确</li>
</ul>
<p>示例代码</p>
<ol>
<li><p>程序源码：判断三边是否可以组成三角形</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Triangle</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a=a;</span><br><span class="line">        <span class="keyword">this</span>.b=b;</span><br><span class="line">        <span class="keyword">this</span>.c=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeTriangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> resulet =<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>||b==<span class="number">0</span>||c==<span class="number">0</span>)&#123;</span><br><span class="line">            resulet=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> resulet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a+b&lt;=c)&#123;</span><br><span class="line">            resulet=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> resulet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a+c&lt;=b)&#123;</span><br><span class="line">            resulet=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> resulet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b+c&lt;=a)&#123;</span><br><span class="line">            resulet=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> resulet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resulet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TriangleTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"开始测试\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">judgeTriangle1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertFalse(<span class="keyword">new</span> Triangle(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>).judgeTriangle());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@After</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试结束\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">judgeTriangle2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertFalse(<span class="keyword">new</span> Triangle(<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>).judgeTriangle());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">judgeTriangle3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertFalse(<span class="keyword">new</span> Triangle(<span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>).judgeTriangle());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">judgeTriangle4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertTrue(<span class="keyword">new</span> Triangle(<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>).judgeTriangle());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="使用Assert断言"><a href="#使用Assert断言" class="headerlink" title="使用Assert断言"></a>使用Assert断言</h2><ul>
<li>断言相等：assertEquals(100,x)</li>
<li>断言数组相等：assertArrayEquals({1,2,3},x)</li>
<li>浮点断言相等：assertEquals(3.1416,x,0.0001)</li>
<li>断言为null: assertNull(x)</li>
<li>断言为true/false：assertTrue(x&gt;0) assertFalse(x&lt;0)</li>
<li>其他：assertNotEquals/assertNotNull</li>
</ul>
<h2 id="BeforeClass-amp-AfterClass-静态方法"><a href="#BeforeClass-amp-AfterClass-静态方法" class="headerlink" title="@BeforeClass &amp; @AfterClass 静态方法"></a>@BeforeClass &amp; @AfterClass 静态方法</h2><ol>
<li>在执行所有@Test方法前执行@BeforeClass静态方法</li>
<li>执行所有测试</li>
<li>在执行所有@Test方法后执行@AfterClass静态方法</li>
</ol>
<p>注意：</p>
<ul>
<li>@BeforeClass静态方法初始化的对象只能存放在静态字段中</li>
<li>静态字段的状态会影响所有的@Test</li>
</ul>
<h2 id="JUnit-Fixture"><a href="#JUnit-Fixture" class="headerlink" title="JUnit Fixture"></a>JUnit Fixture</h2><p>初始化资源成为Fixture</p>
<ul>
<li>@Before：初始化测试对象，例如input= new FileInputStream();</li>
<li>@After: 销毁@Before 创建的测试对象，例如input.close();</li>
<li>@BeforeClass: 初始化非常耗时的资源，例如创建数据库</li>
<li>@AfterClass：清理@BeforeClass创建的资源，例如删除数据库</li>
</ul>
<h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p>异常本就是方法签名的一部分</p>
<ul>
<li><p>public static int parseInt(String s )==throw NumberFormatException==</p>
</li>
<li><p>测试错误的输入是否导致特定的异常</p>
<ul>
<li>Integer.parseInt(null)</li>
<li>Integer.parseInt(“”)</li>
<li>Integer.parseInt(“xyz”)</li>
</ul>
</li>
</ul>
<p>使用expected测试异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = NumberFormatException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">void</span> <span class="title">testNumberFormatException</span>()</span>&#123;</span><br><span class="line">    Integer.parseInt(<span class="keyword">null</span>);<span class="comment">//将字符串参数作为带符号的十进制整数。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><p>如果待测试的输入输出是一组数据：</p>
<ol>
<li>可以把测试数据组织起来</li>
<li>用不同的测试数据调用相同的测试方法</li>
</ol>
<p>测试：</p>
<ul>
<li>参数必须由静态方法data()返回</li>
<li>返回类型为Collection&lt;Object[]&gt;</li>
<li>静态方法必须标记为@Parameters</li>
<li>测试类必须标记为@RunWith（Parameterized.class)</li>
<li>构造方法参数必须和测试参数对应</li>
</ul>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(Parameterized<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">static</span> <span class="title">class</span> <span class="title">AbsTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;?&gt; data() &#123;</span><br><span class="line">      <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][] &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;&#125;);<span class="comment">//提供三种参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> input;</span><br><span class="line">    <span class="keyword">int</span> expected;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbsTest</span><span class="params">(<span class="keyword">int</span> input, <span class="keyword">int</span> expected)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.input = input;</span><br><span class="line">      <span class="keyword">this</span>.expected = expected;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAbs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> r = Math.abs(<span class="keyword">this</span>.input);</span><br><span class="line">      assertEquals(<span class="keyword">this</span>.expected, r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="超时测试"><a href="#超时测试" class="headerlink" title="超时测试"></a>超时测试</h2><p>可以为JUnit的单个测试设置超时：</p>
<ul>
<li>超时设置为1s： @Test(timeout=1000)</li>
</ul>
<p>程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PI</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> positive = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; i += <span class="number">2</span>) &#123;</span><br><span class="line">      sum = sum + (positive ? <span class="number">4.0</span> : -<span class="number">4.0</span>) / i;</span><br><span class="line">      positive = !positive;</span><br><span class="line">      n++;</span><br><span class="line">      <span class="keyword">if</span> (n == count) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PITest</span> </span>&#123;</span><br><span class="line">    PI pi =<span class="keyword">new</span> PI();</span><br><span class="line">    <span class="meta">@Test</span>(timeout = <span class="number">100</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testlk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> r = pi.calculate(<span class="number">1000</span>);</span><br><span class="line">        assertEquals(<span class="number">3.14</span>,r,<span class="number">0.01</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span>(timeout = <span class="number">500</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testlm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> r = pi.calculate(<span class="number">1000000</span>);</span><br><span class="line">        assertEquals(<span class="number">3.1416</span>,r,<span class="number">0.001</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Java后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo图片插入的bug</title>
    <url>/2020/06/14/Hexo%E5%9B%BE%E7%89%87%E6%8F%92%E5%85%A5%E7%9A%84bug/</url>
    <content><![CDATA[<h2 id="图片-bug"><a href="#图片-bug" class="headerlink" title="图片 bug"></a>图片 bug</h2><blockquote>
<p>在搭建Hexo+Next框架的博客时，一直没办法再md中插入图片，路径总是出错。</p>
<p>在查找资料后发现：</p>
<p>使用 npm install <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCodeFalling%2Fhexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save 安装0.0.5版本的hexo-asset-image插件。 使用 npm install hexo-asset-image –save 安装的是1.0.0版本的hexo-asset-image插件。 两者最直接的区别是映射关系不同。 具体详情见<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.99708.com.cn%2F2019%2F07%2F26%2Fhexo-" target="_blank" rel="noopener">http://www.99708.com.cn/2019/07/26/hexo-</a>本地图片不显示</p>
<p>但是再安装时不知为什么总是会报错，所以我们直接修改/node_modules/hexo-asset-image/index.js的代码，如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    	<span class="keyword">var</span> link = data.permalink;</span><br><span class="line">	<span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">	   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line">	<span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line">			<span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">			<span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">			<span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">			   !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">			  <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">			  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">			  <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">				srcArray.shift();</span><br><span class="line">			  src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">			  $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">			  <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">			<span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-02</title>
    <url>/2020/06/14/JavaSE-02/</url>
    <content><![CDATA[<h2 id="StringBuilder类和StringBuffer类"><a href="#StringBuilder类和StringBuffer类" class="headerlink" title="StringBuilder类和StringBuffer类"></a>StringBuilder类和StringBuffer类</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这两个类都是用于字符串拼接，其实String用+号也可以实现拼接，那么为什么要引入这两个类呢？</p>
<p>因为String类型使用+进行拼接字符串时，会产生大量临时字符串，而StringBuilder/StringBuffer只产生一个对象。节省内存资源。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>StringBuilder是线程不安全的，但是效率非常高。</li>
<li>StringBuffer是线程安全的。</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><p>append(String s);</p>
</li>
<li><p>reverse(); </p>
<blockquote>
<p>将字符序列用其反转形式取代</p>
</blockquote>
</li>
<li><p>delete(int start , int end)</p>
<blockquote>
<p>移除此序列的子字符串中的字符</p>
</blockquote>
</li>
<li><p>insert(int offset,String str)</p>
<blockquote>
<p>在下标offset之后插入字符串str</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb1.append(<span class="string">"hello"</span>);</span><br><span class="line">    sb1.append(<span class="string">" world"</span>);</span><br><span class="line">    sb1.reverse();</span><br><span class="line">    String str=sb1.toString();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">	sb1.reverse();</span><br><span class="line">    System.out.println(sb1);</span><br><span class="line">    sb1.insert(<span class="number">5</span>,<span class="string">" this"</span>);</span><br><span class="line">    System.out.println(sb1);</span><br><span class="line">    sb1.delete(<span class="number">5</span>,<span class="number">10</span>);<span class="comment">//左闭右开</span></span><br><span class="line">    System.out.println(sb1);</span><br><span class="line">	<span class="comment">//键入</span></span><br><span class="line"> Scanner in =<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    StringBuilder sbu =<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sbu.append(in.next());</span><br><span class="line">    System.out.println(sbu.toString());</span><br></pre></td></tr></table></figure>

<p>其大多数方法与String类的相同。</p>
]]></content>
      <categories>
        <category>Java后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Wechat</title>
    <url>/2020/06/14/JavaSE-04/</url>
    <content><![CDATA[<p><img src="/2020/06/14/JavaSE-04/code.png" alt="code"></p>
]]></content>
      <categories>
        <category>Java后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaSE-01</title>
    <url>/2020/06/14/JavaSE-01/</url>
    <content><![CDATA[<h2 id="JAVA-String类"><a href="#JAVA-String类" class="headerlink" title="JAVA String类"></a>JAVA String类</h2><h3 id="String-3大特性"><a href="#String-3大特性" class="headerlink" title="String 3大特性"></a>String 3大特性</h3><ul>
<li>不变性：是一个 immutable 模式的对象，不变模式的主要作用是当一个对象需要被多线程共享并 频繁访问时，可以保证数据的⼀致性。 </li>
<li>常量量池优化：String 对象创建之后，会在字符串常量池中进行缓存，下次创建同样的对象时，会直 接返回缓存的引⽤。</li>
<li>final: String类不可被继承，提⾼了系统的安全性。<a id="more"></a>

</li>
</ul>
<h3 id="String-的实例例化有两种⽅方式："><a href="#String-的实例例化有两种⽅方式：" class="headerlink" title="String 的实例例化有两种⽅方式："></a>String 的实例例化有两种⽅方式：</h3><ul>
<li><p>直接赋值</p>
</li>
<li><p>通过构造函数，可以直接将字符串串的值传入，也可以传入⼀个 char 数组。</p>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4></li>
<li><p>直接赋值和通过构造函数创建主要区别在于存储的区域不同，直接赋值存储在字符串常量池中。</p>
</li>
<li><p>通过构造函数创建，存储在堆内存中。</p>
</li>
</ul>
<h3 id="equals重写"><a href="#equals重写" class="headerlink" title="equals重写"></a>equals重写</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">	String aString = (String)anObject;</span><br><span class="line">    <span class="keyword">if</span> (coder() == aString.coder()) &#123;</span><br><span class="line">    <span class="keyword">return</span> isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 String 类对 equals 方法进行了重写，所以我们可以直接调用String 的 equals 方法来判断两个字 符串的值是否相等。</p>
</blockquote>
<h3 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern() 方法"></a>intern() 方法</h3><ul>
<li>当调用某个字符串对象的 intern() ⽅方式，会去字符串常量池中寻找，如果已经存在一个值相等的字符串对象的话，则直接返回该对象的引用，如果不存在，则在字符串常量池中创建该对象，并返回。</li>
</ul>
<h3 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public String()</td>
<td>创建一个值为空的对象</td>
</tr>
<tr>
<td>public String(String original )</td>
<td>创建一个值为original的对象</td>
</tr>
<tr>
<td>public String(char value[])</td>
<td>将一个char型数组转为字符串对象</td>
</tr>
<tr>
<td>public String(char value[],  int offset, int count)</td>
<td>将一个指定范围的char型数组转为字符串 对象</td>
</tr>
<tr>
<td>public String(byte[] bytes)</td>
<td>将⼀个byte型数组转为字符串对象</td>
</tr>
<tr>
<td>public String(byte bytes[], int offset, int length)</td>
<td>将⼀个指定范围的byte型数组转为字符串对象</td>
</tr>
<tr>
<td>public int length()</td>
<td>返回字符串的长度</td>
</tr>
<tr>
<td>public boolean isEmpty()</td>
<td>判断字符串是否为空</td>
</tr>
<tr>
<td>public char charAt(int index)</td>
<td>返回字符串中指定位置的字符</td>
</tr>
<tr>
<td>public byte[] getBytes()</td>
<td>将字符串转为byte型数组</td>
</tr>
<tr>
<td>public boolean equals(Object anObject)</td>
<td>判断两个字符串是否相等</td>
</tr>
<tr>
<td>public boolean equalsIgnoreCase(String anotherString)</td>
<td>判断两个字符串是否相等并且忽略大小写</td>
</tr>
<tr>
<td>public int compareTo(String anotherString)</td>
<td>对两个字符串进行排序</td>
</tr>
<tr>
<td>public boolean startsWith(String prefix)</td>
<td>判断是否以指定的值开头</td>
</tr>
<tr>
<td>public boolean endsWith(String suffix)</td>
<td>判断是否以指定的值结尾</td>
</tr>
<tr>
<td>public int hashCode()</td>
<td>获取字符串的散列值</td>
</tr>
<tr>
<td>public int indexOf(String str)</td>
<td>从头开始查找指定字符的位置</td>
</tr>
<tr>
<td>public int indexOf(String str, int fromIndex)</td>
<td>从指定的位置开始查找指定字符的位置</td>
</tr>
<tr>
<td>==public String substring(int beginIndex)==</td>
<td>截取字符串串从指定位置开始到结尾</td>
</tr>
<tr>
<td>public String substring(int beginIndex, int endIndex)</td>
<td>截取字符串从指定位置开始到指定位置结束</td>
</tr>
<tr>
<td>public String concat(String str)</td>
<td>追加字符串</td>
</tr>
<tr>
<td>public String replaceAll(String regex, String replacement)</td>
<td>替换字符串</td>
</tr>
<tr>
<td>public String[] split(String regex)</td>
<td>⽤指定字符串对目标字符串进⾏分割，返 回数组</td>
</tr>
<tr>
<td>public String toLowerCase()</td>
<td>将字符串转为小写</td>
</tr>
<tr>
<td>public String to Uppercase()</td>
<td>将字符串转为大写</td>
</tr>
<tr>
<td>public char[] toCharArray()</td>
<td>将字符串转为char型数组</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] array = &#123;<span class="string">'J'</span>,<span class="string">'a'</span>,<span class="string">'v'</span>,<span class="string">'a'</span>,<span class="string">','</span>,<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">','</span>,<span class="string">'W'</span>,<span class="string">'o'</span>,<span class="string">'r'</span>,<span class="string">'l'</span>,<span class="string">'d'</span>&#125;; </span><br><span class="line">String str = <span class="keyword">new</span> String(array); </span><br><span class="line">System.out.println(str); System.out.println(<span class="string">"str长度："</span>+str.length()); </span><br><span class="line">System.out.println(<span class="string">"str是否为空："</span>+str.isEmpty()); </span><br><span class="line">System.out.println(<span class="string">"下标为2的字符是："</span>+str.charAt(<span class="number">2</span>)); </span><br><span class="line">System.out.println(<span class="string">"H的下标是："</span>+str.indexOf(<span class="string">'H'</span>)); </span><br><span class="line">String str2 = <span class="string">"Hello"</span>; </span><br><span class="line">System.out.println(<span class="string">"str和str2是否相等："</span>+str.equals(str2)); </span><br><span class="line">String str3 = <span class="string">"HELLO"</span>; </span><br><span class="line">System.out.println(<span class="string">"str2和str3忽略略⼤大⼩小写是否相等："</span>+str2.equalsIgnoreCase(str3)); </span><br><span class="line">System.out.println(<span class="string">"str是否以Java开头："</span>+str.startsWith(<span class="string">"Java"</span>)); </span><br><span class="line">System.out.println(<span class="string">"str是否以Java结尾："</span>+str.endsWith(<span class="string">"Java"</span>));</span><br><span class="line">System.out.println(<span class="string">"从2开始截取str："</span>+str.substring(<span class="number">2</span>)); </span><br><span class="line">System.out.println(<span class="string">"从2到6截取str："</span>+str.substring(<span class="number">2</span>, <span class="number">6</span>)); </span><br><span class="line">System.out.println(<span class="string">"将str中的World替换为Java："</span>+str.replaceAll(<span class="string">"World"</span>, <span class="string">"Java"</span>)); </span><br><span class="line">System.out.println(<span class="string">"⽤用逗号分割str："</span>+Arrays.toString(str.split(<span class="string">","</span>))); </span><br><span class="line">System.out.println(<span class="string">"将str转为char类型数组："</span>+Arrays.toString(str.toCharArray())); </span><br><span class="line">System.out.println(<span class="string">"str3转为⼩小写："</span>+str3.toLowerCase());</span><br><span class="line">System.out.println(<span class="string">"str2转为⼤大写："</span>+str2.toUpperCase());</span><br></pre></td></tr></table></figure>

<h4 id="字符串截取和分割"><a href="#字符串截取和分割" class="headerlink" title="字符串截取和分割"></a>字符串截取和分割</h4><ul>
<li><p>字符串截取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span></span><br></pre></td></tr></table></figure>

<p>substring(int beginIndex) 是从下标为 beginIndex 的位置开始截取，⼀一直到字符串串的结尾。<br>substring(int beginIndex, int endIndex) 是从下标为 beginIndex 的位置开始截取，一直到 endIndex 的位置结束，且不包括该位置的字符。<br>需要注意的是 substring 方法会将截取的结果以新字符串的形式返回，原字符串的值不会改变，具体操作如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Hello World"</span>); </span><br><span class="line">System.out.println(str.substring(<span class="number">3</span>)); </span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串分割</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex);</span><br></pre></td></tr></table></figure>

<p>split 方法支持传入正则表达式，进行复杂的字符串分割，比如 “Hello,World;Java-String”，如果要分别 将 Hello、World、Java、String 截取出来，使⽤用统一的某个分割符肯定⽆无法完成，这时候可以借助于正则表达式 “[,|;|-]” 来实现，具体操作如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Hello,World;Java-String"</span>); </span><br><span class="line">String[] array = str.split(<span class="string">"[,|;|-]"</span>); </span><br><span class="line"><span class="keyword">for</span> (String item:array)&#123; </span><br><span class="line">	System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3></li>
</ul>
<ol>
<li><p>== 和 equals 的区别？<br>== 可以理理解为是⽐比较栈内存中的值，如果变量量是基本数据类型，则栈内存中存放的就是具体数值，如 果是引⽤用类型，则栈中存放的是引⽤用的内存地址。所以对于基本数据类型，== 是比较值是否相等，对于引用数据类型，比较的是引用的内存地址是否相等。</p>
<p><img src="/2020/06/14/JavaSE-01/String.PNG" alt></p>
</li>
<li><p>equals 是 Object 类提供的一个⽅方法，其本质就是在用 == 进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 Java 中任意⼀一个类都可以对其进⾏行行重写，根据具体需求重新定义其判断逻辑，⽐比如我们⾃自定义⼀一 个 Student 类，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; </span><br><span class="line">	<span class="keyword">private</span> Integer id; </span><br><span class="line">	<span class="keyword">private</span> String name; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id, String name)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">this</span>.id = id; </span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建两个成员变量量值完全相等的实例例化对象，并⽤用 equals ⽅方法判断是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student1 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"张三"</span>); </span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"张三"</span>); </span><br><span class="line">System.out.println(student1.equals(student2));</span><br></pre></td></tr></table></figure>

<p>结果为 false，因为两个实例化对象必然会在堆内存中开辟两块空间来存储，所以内存地址一定是不相同的。而在现实的逻辑中，如果两个学生的 id 和 name 都一样，那么我们就认为他们是同一个学⽣用程序如何来实现呢？通过重写equals方法即可，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; </span><br><span class="line">	<span class="keyword">private</span> Integer id; </span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id, String name)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">this</span>.id = id; </span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123; </span><br><span class="line">	Student student = (Student) obj; 	</span><br><span class="line">    <span class="keyword">if</span>(id.equals(student.id) &amp;&amp; name.equals(student.name))&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下述代码的运⾏行行结果是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"Hello World"</span>; </span><br><span class="line">String str2 = <span class="string">"Hello"</span>+<span class="string">" World"</span>; </span><br><span class="line">System.out.println(str1 == str2);</span><br></pre></td></tr></table></figure>

<p>true，”Hello” 和 “ World” 都是字符串字面值，字符串字面值 + 字符串字面值的结果仍然保存在字符串常量池中，所以 str1 和 str2 相同。</p>
</li>
<li><p>下述代码的运⾏结果是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"Hello World"</span>; </span><br><span class="line">String str2 = <span class="string">"Hello"</span>; </span><br><span class="line">str2 += <span class="string">" World"</span>; </span><br><span class="line">System.out.println(str1 == str2);</span><br></pre></td></tr></table></figure>

<p>false，这题看似与第 2 题一样，但结果不同，因为 str2 = “Hello”+” World” 是直接创建， str2 = “Hello”; str2 += “ World”; 是先创建再修改，同时修改完成之后的字符串是放在堆内存中的，为什么 呢？因为 str2 是一个字符串变量，” World” 是字符串字面值，当字符串字面值与 String 类型变量拼接 时，得到的新字符串不再保存在常量池中，⽽而是在堆中开辟一块新的空间来存储。</p>
</li>
<li><p>下述代码的运行结果是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"Hello World"</span>; </span><br><span class="line">String str2 = <span class="string">" World"</span>;</span><br><span class="line">String str3 = <span class="string">"Hello"</span>+str2; </span><br><span class="line">System.out.println(str1 == str3);</span><br></pre></td></tr></table></figure>

<p>false，str2 是变量，”Hello” 是字符串字面值，字符串字面值 + 变量会在堆内存中开辟新的空间来存储，所以 str1 和 str3 不同。</p>
</li>
<li><p>下述代码的运⾏结果是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"Hello World"</span>; </span><br><span class="line"><span class="keyword">final</span> String str2 = <span class="string">" World"</span>; </span><br><span class="line">String str3 = <span class="string">"Hello"</span>+str2; </span><br><span class="line">System.out.println(str1 == str3);</span><br></pre></td></tr></table></figure>

<p>true，”Hello” 是字符串字面值，str2 是常量，字符串字⾯值+常量的结果仍然保存在字符串常量池中， 所以 str1 和 str3 相同。</p>
</li>
<li><p>下述代码的运⾏结果是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">final</span> String str2 = <span class="keyword">new</span> String(<span class="string">" World"</span>); </span><br><span class="line">String str3 = <span class="string">"Hello"</span>+str2; </span><br><span class="line">System.out.println(str1 == str3);</span><br></pre></td></tr></table></figure>

<p>false，str2 是常量，但是 new String(“ World”) 保存在堆内存中，所以即使用 final 进⾏了修饰， str2 仍然保存在堆中，则 str3 也就保存在堆中，所以 str1 和 str3 不同。</p>
</li>
<li><p>下述代码的运⾏结果是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"Hello World"</span>; </span><br><span class="line">String str2 = <span class="string">"Hello"</span>; </span><br><span class="line">String str3 = <span class="string">" World"</span>; </span><br><span class="line">String str4 = str2 + str3; </span><br><span class="line">System.out.println(str4 == str1); </span><br><span class="line">System.out.println(str4.intern() == str1);</span><br></pre></td></tr></table></figure>

<p>false,true,当调用str4的intern方法时,如果字符串常量池已经包含一个等于 str4 的字符串，则返回该字符串，否则将 str4 添加到字符串常量池中，并返回其引用，所以 str4.intern() 与 str1 相同。</p>
</li>
<li><p>什么是字符串常量池？</p>
<p>字符串常量池位于堆内存中，专门⽤来存储字符串常量，可以提⾼高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时JVM 会⾸首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化⼀个字符串放到池中，并返回其引用。</p>
</li>
<li><p>堆内存与栈内存的区别</p>
<p>基于上边的解释我们可以很简单的总结出堆和栈的区别：</p>
<p>1、应用程序所有的部分都使用堆内存，然后栈内存通过一个线程运行来使用。</p>
<p>2、不论对象什么时候创建，他都会存储在堆内存中，栈内存包含它的引用。栈内存只包含原始值变量好和堆中对象变量的引用。</p>
<p>3、存储在堆中的对象是全局可以被访问的，然而栈内存不能被其他线程所访问。</p>
<p>4、栈中的内存管理使用LIFO的方式完成，而堆内存的管理要更复杂了，因为它是全局被访问的。堆内存被分为，年轻一代，老一代等等，更多的细节请看，<a href="http://www.journaldev.com/2856/java-jvm-memory-model-and-garbage-collection-monitoring-tuning" target="_blank" rel="noopener">这篇文章</a></p>
<p>5、栈内存是生命周期很短的，然而堆内存的生命周期从程序的运行开始到运行结束。</p>
<p>6、我们可以使用-Xms和-Xmx JVM选项定义开始的大小和堆内存的最大值，我们可以使用-Xss定义栈的大小</p>
<p>7、当栈内存满的时候，Java抛出java.lang.StackOverFlowError异常而堆内存满的时候抛出java.lang.OutOfMemoryError: Java Heap Space错误</p>
<p>8、和堆内存比，栈内存要小的多，因为明确使用了内存分配规则（LIFO），和堆内存相比栈内存非常快。</p>
</li>
<li><p>String 是线程安全的吗？</p>
<p>String 是不可变类，⼀旦创建了String对象，我们就无法改变它的值。因此，它是线程安全的，同一个字符串实例可以被多个线程共享，保证了多线程的安全性。</p>
</li>
<li><p>在使用HashMap的时候，用 String 做 key 有什么好处？</p>
<p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，⽽因为字符串是不可变的，当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
</li>
</ol>
]]></content>
  </entry>
</search>
